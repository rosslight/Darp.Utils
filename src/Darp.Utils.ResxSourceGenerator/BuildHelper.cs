namespace Darp.Utils.ResxSourceGenerator;

using System.Collections.Immutable;
using System.Diagnostics.CodeAnalysis;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Diagnostics;

internal static class BuildHelper
{
    public static bool TryGenerateSource(ResourceCollection resourceCollection,
        out IEnumerable<Diagnostic> diagnostics,
        out string fileHintName,
        [NotNullWhen(true)] out string? sourceCode,
        CancellationToken cancellationToken)
    {
        (ResourceInformation resourceInformation, ImmutableArray<AdditionalText> others, fileHintName) = resourceCollection;
        diagnostics = [];
        if (!resourceInformation.TryComputeProperties(out ComputedProperties properties))
        {
            sourceCode = null;
            return false;
        }

        GenerateNamespaceStartAndEnd(properties.Namespace,
            out var namespaceStart,
            out var classIndent,
            out var memberIndent,
            out var namespaceEnd);
        if (!TryGenerateMembers(out var members))
        {
            sourceCode = null;
            return false;
        }
        var keysClass = GenerateKeysClass();
        var debugInformation = resourceCollection.GenerateDebugInformation(properties, classIndent);
        var defaultClass = $$"""
{{classIndent}}/// <summary>A strongly typed resource class for '{{resourceInformation.ResourceFile.Path}}'</summary>
{{debugInformation}}
{{classIndent}}{{(resourceInformation.Settings.Public ? "public" : "internal")}} sealed partial class {{properties.ClassName}}
{{classIndent}}{
{{memberIndent}}private static {{properties.ClassName}}? _default;
{{memberIndent}}/// <summary>The Default implementation of <see cref="{{properties.ClassName}}"/></summary>
{{memberIndent}}public static {{properties.ClassName}} Default => _default ??= new {{properties.ClassName}}();

{{memberIndent}}public delegate void CultureChangedDelegate(global::System.Globalization.CultureInfo? oldCulture, global::System.Globalization.CultureInfo? newCulture);
{{memberIndent}}/// <summary>Called after the <see cref="Culture"/> was updated. Provides previous culture and the newly set culture</summary>
{{memberIndent}}public event CultureChangedDelegate? CultureChanged;

{{memberIndent}}private global::System.Globalization.CultureInfo? _culture;
{{memberIndent}}/// <summary>Get or set the Culture to be used for all resource lookups issued by this strongly typed resource class.</summary>
{{memberIndent}}public System.Globalization.CultureInfo? Culture
{{memberIndent}}{
{{memberIndent}}    get => _culture;
{{memberIndent}}    set
{{memberIndent}}    {
{{memberIndent}}        System.Globalization.CultureInfo? oldCulture = _culture;
{{memberIndent}}        _culture = value;
{{memberIndent}}        if (!System.Collections.Generic.EqualityComparer<System.Globalization.CultureInfo>.Default.Equals(oldCulture, value))
{{memberIndent}}            CultureChanged?.Invoke(oldCulture, value);
{{memberIndent}}    }
{{memberIndent}}}

{{memberIndent}}///<summary>Returns the cached ResourceManager instance used by this class.</summary>
{{memberIndent}}[global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Advanced)]
{{memberIndent}}public global::System.Resources.ResourceManager ResourceManager { get; } = new global::System.Resources.ResourceManager("{{properties.ResourceName}}", typeof({{properties.ClassName}}).Assembly);

{{memberIndent}}/// <summary>Get a resource of the <see cref="ResourceManager"/> with the configured <see cref="Culture"/> as a string</summary>
{{memberIndent}}/// <param name="resourceKey">The name of the resource to get</param>
{{memberIndent}}/// <returns>Returns the resource value as a string or the <paramref name="resourceKey"/> if it could not be found</returns>
{{memberIndent}}[global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
{{memberIndent}}public string GetResourceString(string resourceKey) => ResourceManager.GetString(resourceKey, Culture) ?? resourceKey;

{{members}}
{{keysClass}}
{{classIndent}}}
""";
        var result = $"""
// <auto-generated/>

#nullable enable
using System.Reflection;

{namespaceStart}
{defaultClass}
{namespaceEnd}

""";
        sourceCode =  result.Replace("\r\n", "\n");
        return true;
    }

    private static string GenerateDebugInformation(this ResourceCollection resourceCollection,
        ComputedProperties properties, string classIndent)
    {
        ResourceInformation resourceInformation = resourceCollection.BaseInformation;
        return $"""
{classIndent}/// <remarks>
{classIndent}/// Files:
{classIndent}/// FileHintName: {resourceCollection.FileHintName}
{string.Join("\n", resourceCollection.OtherLanguages.Select(x => $"{classIndent}/// {x.Path}"))}
{classIndent}/// Configuration:
{classIndent}/// RootNamespace: {resourceInformation.Settings.RootNamespace}
{classIndent}/// RelativeDir: {resourceInformation.Settings.RelativeDir}
{classIndent}/// ClassName: {resourceInformation.Settings.ClassName}
{classIndent}/// Public: {resourceInformation.Settings.Public}
{classIndent}/// EmitFormatMethods: {resourceInformation.Settings.EmitFormatMethods}
{classIndent}/// Compilation info:
{classIndent}/// Assembly: {resourceInformation.CompilationInformation.AssemblyName}

{classIndent}/// Computed properties:
{classIndent}/// ResourceName: {properties.ResourceName}
{classIndent}/// ClassName: {properties.ClassName}
{classIndent}/// Namespace: {properties.Namespace}
{classIndent}/// </remarks>
""";
    }

    private static string GenerateKeysClass()
    {
        return "";
    }

    private static bool TryGenerateMembers(out string strings)
    {
        strings = "";
        return true;
    }

    private static void GenerateNamespaceStartAndEnd(string? namespaceName,
        out string? namespaceStart,
        out string classIndent,
        out string memberIndent,
        out string? namespaceEnd)
    {
        const string indent = "    ";
        if (namespaceName is null)
        {
            namespaceStart = null;
            classIndent = "";
            namespaceEnd = null;
        }
        else
        {
            namespaceStart = $$"""
namespace {{namespaceName}}
{
""";
            classIndent = indent;
            namespaceEnd = "}";
        }
        memberIndent = classIndent + indent;
    }

    private static bool SplitName(string fullName,
        [NotNullWhen(true)] out string? namespaceName,
        out string className)
    {
        var lastDot = fullName.LastIndexOf('.');
        if (lastDot == -1)
        {
            namespaceName = null;
            className = fullName;
            return false;
        }
        namespaceName = fullName[..lastDot];
        className = fullName[(lastDot + 1)..];
        return true;
    }

    public delegate bool TryParseDelegate<T>(string value, [NotNullWhen(true)] out T? result)
        where T : class;
    public delegate bool TryParseDelegateStruct<T>(string value, [NotNullWhen(true)] out T result)
        where T : struct;

    public static bool? GetBoolValue(this AnalyzerConfigOptions options, string key) => options
        .GetStructValue(key, (string value, out bool result) => bool.TryParse(value, out result));
    public static T? GetStructValue<T>(this AnalyzerConfigOptions options,
        string key,
        TryParseDelegateStruct<T> tryParse)
        where T : struct
    {
        if (options.TryGetValue(key, out var stringValue)
            && tryParse(stringValue, out T value))
        {
            return value;
        }
        return null;
    }
    public static string? GetValue(this AnalyzerConfigOptions options,
        string key)
    {
        return options.TryGetValue(key, out var stringValue) ? stringValue : null;
    }

    private static bool TryComputeProperties(this ResourceInformation resourceInformation, out ComputedProperties properties)
    {
        var resourcePathName = Path.GetFileNameWithoutExtension(resourceInformation.ResourceFile.Path);
        var resourceName = resourcePathName;
        if (resourceInformation.Settings.RelativeDir is not null)
        {
            var relativeDir = resourceInformation.Settings.RelativeDir
                .Replace(Path.DirectorySeparatorChar, '.')
                .Replace(Path.AltDirectorySeparatorChar, '.');
            resourceName = relativeDir + resourceName;
        }
        var resourceAccessName = resourceInformation.Settings.ClassName is null || string.IsNullOrEmpty(resourceInformation.Settings.ClassName)
            ? string.Join(".", resourceInformation.Settings.RootNamespace, resourceName)
            : resourceInformation.Settings.ClassName;
        SplitName(resourceAccessName, out var namespaceName, out var className);
        properties = new ComputedProperties(
            ResourceName: resourceName,
            Namespace: namespaceName,
            ClassName: className
            );
        return true;
    }

    internal static bool IsChildFile(string fileToCheck, IEnumerable<string> availableFiles)
    {
        SplitName(fileToCheck, out var parentFileName, out var languageExtension);
        if (!availableFiles.Contains(parentFileName))
        {
            return false;
        }
        var lastNumberOfCodes = 0;
        var sections = 0;
        foreach (var character in languageExtension)
        {
            switch (character)
            {
                case '-' when lastNumberOfCodes < 2 || sections > 1:
                    return false;
                case '-':
                    lastNumberOfCodes = 0;
                    sections++;
                    continue;
                default:
                    lastNumberOfCodes++;
                    break;
            }
        }
        return lastNumberOfCodes is not (> 4 or < 2);
    }
}
