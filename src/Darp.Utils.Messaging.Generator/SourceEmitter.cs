namespace Darp.Utils.Messaging.Generator;

using System.CodeDom.Compiler;
using System.Diagnostics.CodeAnalysis;
using Microsoft.CodeAnalysis;
using static RoslynHelper;

internal static class SourceEmitter
{
    public static bool TryEmit(
        SourceTypeInfo sourceInfo,
        [NotNullWhen(true)] out string? code,
        out List<Diagnostic> diagnostics
    )
    {
        using var stringWriter = new StringWriter();
        using var writer = new IndentedTextWriter(stringWriter);
        diagnostics = [];

        writer.WriteMultiLine(
            """
            // <auto-generated/>
            #nullable enable
            #pragma warning disable CS0618 // Suppress obsolete
            """
        );
        writer.WriteLine();
        EmitOptionalNamespaceStart(writer, sourceInfo.Symbol);

        var typeName = sourceInfo.Symbol.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat);
        var publishModifier = sourceInfo.Symbol.IsSealed ? "private" : "protected";
        writer.WriteMultiLine(
            $$"""
            partial class {{typeName}} : global::Darp.Utils.Messaging.IMessageSource
            {
                [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
                {{GetGeneratedVersionAttribute()}}
                [global::System.Obsolete("This field is not intended to be used in use code")]
                private readonly global::System.Collections.Generic.List<global::Darp.Utils.Messaging.IMessageSink> ___messageSinks =
                    new global::System.Collections.Generic.List<global::Darp.Utils.Messaging.IMessageSink>();

                [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
                {{GetGeneratedVersionAttribute()}}
                [global::System.Obsolete("This field is not intended to be used in use code")]
            #if NET9_0_OR_GREATER
                private readonly global::System.Threading.Lock ___lock = new global::System.Threading.Lock();
            #else
                private readonly object ___lock = new object();
            #endif

                /// <summary> Publish a new message </summary>
                /// <param name="message"> The message to be published </param>
                /// <typeparam name="T"> The type of the message to be published </typeparam>
                {{GetGeneratedVersionAttribute()}}
                {{publishModifier}} void PublishMessage<T>(in T message)
            #if NET9_0_OR_GREATER
                    where T : allows ref struct
            #endif
                {
                    lock (___lock)
                    {
                        // Reversed loop in case a subscriber disconnects while .Publish() is called
                        for (var index = ___messageSinks.Count - 1; index >= 0; index--)
                        {
                            global::Darp.Utils.Messaging.IMessageSink eventReceiver = ___messageSinks[index];
                            if (eventReceiver is global::Darp.Utils.Messaging.IMessageSink<T> receiver)
                                receiver.Publish(message);
                            else if (eventReceiver is global::Darp.Utils.Messaging.IAnyMessageSink anyReceiver)
                                anyReceiver.Publish(message);
                        }
                    }
                }

                /// <inheritdoc />
                {{GetGeneratedVersionAttribute()}}
                public global::System.IDisposable Subscribe(global::Darp.Utils.Messaging.IMessageSink sink)
                {
                    lock (___lock)
                    {
                        ___messageSinks.Insert(0, sink);
                        return global::Darp.Utils.Messaging.FuncDisposable.Create(
                            (Lock: ___lock, Sinks: ___messageSinks, Sink: sink),
                            state =>
                            {
                                lock (state.Lock)
                                    state.Sinks.Remove(state.Sink);
                            }
                        );
                    }
                }
            }
            """
        );

        EmitOptionalNamespaceEnd(writer, sourceInfo.Symbol);

        code = stringWriter.ToString();
        return true;
    }
}
