namespace Darp.Utils.Messaging.Generator;

using System.CodeDom.Compiler;
using System.Diagnostics.CodeAnalysis;
using Microsoft.CodeAnalysis;
using static RoslynHelper;
using MethodInfo = (
    bool IsAny,
    bool IsStatic,
    Microsoft.CodeAnalysis.ITypeSymbol TypeSymbol,
    Microsoft.CodeAnalysis.IMethodSymbol MethodSymbol
);

internal static class SinkEmitter
{
    public static bool TryEmit(
        SinkMethodInfo[] methods,
        [NotNullWhen(true)] out string? code,
        out List<Diagnostic> diagnostics
    )
    {
        using var stringWriter = new StringWriter();
        using var writer = new IndentedTextWriter(stringWriter);
        diagnostics = [];

        INamedTypeSymbol parentTypeSymbol = methods[0].Symbol.ContainingType;

        writer.WriteMultiLine(
            """
            // <auto-generated/>
            #nullable enable
            #pragma warning disable CS0618 // Suppress obsolete
            """
        );
        writer.WriteLine();
        EmitOptionalNamespaceStart(writer, parentTypeSymbol);
        writer.WriteLine(
            $"partial class {parentTypeSymbol.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat)} : global::Darp.Utils.Messaging.IMessageSinkProvider"
        );
        writer.WriteLine("{");
        writer.Indent++;
        writer.WriteMultiLine(
            $"""
            [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
            {GetGeneratedVersionAttribute()}
            [global::System.Obsolete("This field is not intended to be used in use code. Use 'GetMessageSink'")]
            private ___MessageSink? ___lazyMessageSink;
            """
        );
        writer.WriteLineNoTabs("");
        writer.WriteMultiLine(
            $$"""
            /// <inheritdoc />
            {{GetGeneratedVersionAttribute()}}
            public global::Darp.Utils.Messaging.IMessageSink GetMessageSink()
            {
                return ___lazyMessageSink ??= new ___MessageSink(this);
            }
            """
        );
        writer.WriteLineNoTabs("");
        if (!TryEmitMessageSink(writer, parentTypeSymbol, methods, diagnostics))
        {
            code = null;
            return false;
        }
        writer.Indent--;
        writer.WriteLine("}");
        EmitOptionalNamespaceEnd(writer, parentTypeSymbol);
        code = stringWriter.ToString();
        return true;
    }

    private static bool TryEmitMessageSink(
        IndentedTextWriter writer,
        INamedTypeSymbol parentTypeSymbol,
        SinkMethodInfo[] methods,
        List<Diagnostic> diagnostics
    )
    {
        List<MethodInfo> messageTypes = [];
        var isValid = true;
        var isCompiledWithNet9OrGreater = methods[0].IsCompiledWithNet9OrGreater;
        foreach (SinkMethodInfo targetMethodInfo in methods)
        {
            var isStatic = targetMethodInfo.Symbol.IsStatic;
            var isAny = false;
            if (targetMethodInfo.Symbol.Parameters.Length != 1)
            {
                isValid = false;
                diagnostics.Add(
                    Diagnostic.Create(
                        DiagnosticDescriptors.InvalidMethodParameters,
                        targetMethodInfo.SinkAttributeData.ApplicationSyntaxReference?.GetSyntax().GetLocation()
                    )
                );
                continue;
            }
            if (targetMethodInfo.Symbol.TypeParameters.Length > 0)
            {
                if (targetMethodInfo.Symbol.TypeParameters.Length > 1)
                {
                    isValid = false;
                    diagnostics.Add(
                        Diagnostic.Create(
                            DiagnosticDescriptors.InvalidMethodTypeParameters,
                            targetMethodInfo.SinkAttributeData.ApplicationSyntaxReference?.GetSyntax().GetLocation()
                        )
                    );
                    continue;
                }
                var allowsRefStruct =
                    targetMethodInfo.Symbol.TypeParameters[0].AllowsRefLikeType || !isCompiledWithNet9OrGreater;
                if (!allowsRefStruct || targetMethodInfo.Symbol.TypeParameters[0].ConstraintTypes.Length > 0)
                {
                    isValid = false;
                    diagnostics.Add(
                        Diagnostic.Create(
                            DiagnosticDescriptors.InvalidMethodTypeConstraint,
                            targetMethodInfo.SinkAttributeData.ApplicationSyntaxReference?.GetSyntax().GetLocation()
                        )
                    );
                    continue;
                }
                isAny = true;
            }
            messageTypes.Add((isAny, isStatic, targetMethodInfo.Symbol.Parameters[0].Type, targetMethodInfo.Symbol));
        }

        if (!isValid)
            return false;
        writer.WriteLine(GetGeneratedVersionAttribute());
        writer.WriteLine("private sealed class ___MessageSink");
        IEnumerable<string> methodParameterTypes = messageTypes
            .Where(x => !x.IsAny)
            .Select(x => x.TypeSymbol)
            .Distinct<ITypeSymbol>(SymbolEqualityComparer.Default)
            .Select(x =>
                $"global::Darp.Utils.Messaging.IMessageSink<{x.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}>"
            )
            .Concat(messageTypes.Any(x => x.IsAny) ? ["global::Darp.Utils.Messaging.IAnyMessageSink"] : []);
        writer.WriteLine($"    : {string.Join(", ", methodParameterTypes)}");
        writer.WriteLine("{");
        writer.Indent++;
        var parentTypeName = parentTypeSymbol.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat);
        writer.WriteMultiLine(
            $$"""
            private readonly {{parentTypeName}} _parent;

            public ___MessageSink({{parentTypeName}} parent)
            {
                _parent = parent;
            }
            
            """
        );
        foreach (
            IGrouping<ITypeSymbol, MethodInfo> methodGrouping in messageTypes
                .Where(x => !x.IsAny)
                .GroupBy(x => x.TypeSymbol, (IEqualityComparer<ITypeSymbol>)SymbolEqualityComparer.Default)
        )
        {
            EmitDefaultPublishMethod(writer, methodGrouping);
        }
        MethodInfo[] anyMethods = messageTypes.Where(x => x.IsAny).ToArray();
        if (anyMethods.Length > 0)
        {
            EmitAnyPublishMethod(writer, anyMethods, isCompiledWithNet9OrGreater);
        }
        writer.Indent--;
        writer.WriteLine("}");
        return isValid;
    }

    private static void EmitAnyPublishMethod(
        IndentedTextWriter writer,
        MethodInfo[] valueTuples,
        bool isCompiledWithNet9OrGreater
    )
    {
        writer.WriteLine("public void Publish<T>(in T message)");
        if (isCompiledWithNet9OrGreater)
            writer.WriteLine("    where T : allows ref struct");
        writer.WriteLine("{");
        writer.Indent++;
        foreach ((_, var isStatic, ITypeSymbol _, IMethodSymbol methodSymbol) in valueTuples)
        {
            if (isStatic)
                writer.WriteMultiLine($"{methodSymbol.Name}(message);");
            else
                writer.WriteMultiLine($"_parent.{methodSymbol.Name}(message);");
        }
        writer.Indent--;
        writer.WriteLine("}");
    }

    private static void EmitDefaultPublishMethod(
        IndentedTextWriter writer,
        IGrouping<ITypeSymbol, MethodInfo> valueTuples
    )
    {
        var typeNameString = valueTuples.Key.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        writer.WriteLine($"public void Publish(in {typeNameString} message)");
        writer.WriteLine("{");
        writer.Indent++;
        foreach ((_, var isStatic, ITypeSymbol _, IMethodSymbol methodSymbol) in valueTuples)
        {
            if (isStatic)
                writer.WriteMultiLine($"{methodSymbol.Name}(message);");
            else
                writer.WriteMultiLine($"_parent.{methodSymbol.Name}(message);");
        }
        writer.Indent--;
        writer.WriteLine("}");
    }
}
